% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_design.R
\name{gen_design}
\alias{gen_design}
\title{Generates the optimal run matrix from candidate set, model, optimality criterion,
and desired number of runs.}
\usage{
gen_design(candidateset, model, trials, splitplotdesign = NULL,
  splitplotsizes = NULL, optimality = "D", repeats = 10,
  varianceratio = 1, contrast = contr.simplex, parallel = FALSE,
  timer = FALSE, disallowedcombinations = FALSE)
}
\arguments{
\item{candidateset}{A data frame of candidate test points. Usually this is a full factorial test matrix
generated for the factors in the model, but if you have disallowed combinations then make sure the candidate list
is consistent with them (e.g. by generating a full factorial and then removing disallowed combinations). If
the factor is continuous, it should be type numeric. If the factor is categorical, it should be
set as a factor.}

\item{model}{The model used to generate the test design.}

\item{trials}{The number of runs in the design.}

\item{splitplotdesign}{For a split-plot design, this is the design for all of the factors harder to change
than the current set of factors. These rows are replicated to the specified size for each block
(given in the argument splitplotsizes) and the optimal design is found for all of the factors given in the
candidateset argument, taking into consideration the fixed and replicated hard-to-change factors.}

\item{splitplotsizes}{Specifies the block size for each row of harder-to-change factors given in the
argument splitplotdesign. If the input is a vector, each entry of the vector determines the size of the sub-plot
for that whole plot setting. If the input is an integer, it generates a balanced design with equal-sized blocks.}

\item{optimality}{The optimality criterion (e.g. "D", "I", or "A")}

\item{repeats}{The number of times to repeat the search for the best optimal condition. If missing, this defaults to 10.}

\item{varianceratio}{Default 1. The ratio between the interblock and intra-block variance for a given stratum in
a split plot design.}

\item{contrast}{Function used to generate the contrasts encoding for categorical variables. Default contr.simplex.}

\item{parallel}{Default FALSE. If TRUE, the optimal design search will use all the available cores. This can lead to a substantial speed-up, for complex designs.}

\item{timer}{Default FALSE. If TRUE, will print an estimate of the optimal design search time.}

\item{disallowedcombinations}{Default FALSE. Set TRUE if the candidate list has had any test points removed.}
}
\value{
The optimal design. Attributes can be accessed with the attr function.
}
\description{
Creates design given a model and desired number of runs, returning the model matrix. Currently
Used with eval_design/eval_design_mc to produce power estimations for designs.
}
\examples{
#Generate the basic factorial design used in generating the optimal design with expand.grid.
#Generating a basic 2 factor design:
basicdesign = expand.grid(x1=c(-1,1), x2=c(-1,1))

#This candidate set is used as an input in the optimal design generation for a
#D-optimal design with 11 runs.
design = gen_design(candidateset=basicdesign, model=~x1+x2, trials=11)

#We can also use the dot operator to automatically use all of the terms in the model:
design = gen_design(candidateset=basicdesign, model=~., trials=11)

#Here we add categorical factors, specified by using "as.factor" in expand.grid:
categoricaldesign = expand.grid(a=c(-1,1), b=as.factor(c("A","B")),
                               c=as.factor(c("High","Med","Low")))

#This candidate set is used as an input in the optimal design generation.
design2 = gen_design(candidateset=categoricaldesign, model=~a+b+c, trials=19)

#We can also increase the number of times the algorithm repeats
#the search to increase the probability that the globally optimal design was found.
design2 = gen_design(candidateset=categoricaldesign, model=~a+b+c, trials=19, repeats=100)

#You can also use a higher order model when generating the design:
design2 = gen_design(candidateset=categoricaldesign, model=~a+b+c+a*b*c, trials=12)

#To evaluate a response surface design, include center points
#in the candidate set and do not include
#quadratic effects with categorical factors.

designquad = expand.grid(a=c(1,0,-1), b=c(-1,0,1), c=c("A","B","C"))

gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20)

#The optimality criterion can also be changed:
gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20,optimality="I")
gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20,optimality="A")

#A split-plot design can be generated by first generating an optimal blocking design using the
#hard-to-change factors and then using that as the input for the split-plots design.
#This generates an optimal subplot design that accounts for the existing split-plot settings.
#See the accompannying paper "___________" for details of the implementation.

hardtochangefactor = expand.grid(Altitude=c(-1,1))
hardtochangedesign = gen_design(candidateset = hardtochangefactor, model=~Altitude, trials=11)

#Now we can use the D-optimal blocked design as an input to our full design.

easytochangefactors = expand.grid(Range=as.factor(c("Close","Medium","Far")), Power=c(1,-1))

#Here, we specify the easy to change factors for the candidate set,
#and input the hard-to-change design along with a vector listing the number
#of repetitions within each block for the blocked design. There should be a size entry
#for every block and the number of runs specified in the trials argument needs to equal the
#sum of all of the block sizes or else the program will throw an error.

#Since we have 11 runs in our hard-to-change design, we need a vector
#specifying the size of each 11 runs. Here we specify the blocks be three runs each
#(meaning the final design will be 33 runs):

splitplotblocksize = rep(3,11)

#Putting this all together:
designsplitplot = gen_design(easytochangefactors, ~Range+Power, trials=33,
                            splitplotdesign=hardtochangedesign,
                            splitplotsizes = splitplotblocksize)

#The split-plot structure is encoded into the row names, with a period
#demarcating the blocking level. This process can be repeated for arbitrary
#levels of blocking (i.e. a split-plot design can be entered in as the hard-to-change
#to produce a split-split-plot design, which can be passed as another
#hard-to-change design to produce a split-split-split plot design, etc).

extremelyhtcfactors = expand.grid(Location=as.character(c("East","West")))
veryhtcfactors = expand.grid(Climate = as.factor(c("Dry","Wet","Arid")))
htcfactors = expand.grid(Vineyard = as.factor(c("A","B","C","D")))
etcfactors = expand.grid(Age = c(1,-1))

gen_design(extremelyhtcfactors, ~Location, trials=6,varianceratio=2) -> temp
gen_design(veryhtcfactors, ~Climate, trials=12, splitplotdesign = temp, splitplotsizes=rep(2,6),
          varianceratio=1) -> temp
gen_design(htcfactors, ~Vineyard, 48, splitplotdesign = temp, splitplotsizes = rep(4,12),
          varianceratio=1) -> temp
gen_design(etcfactors, ~Age, 192, splitplotdesign = temp, splitplotsizes = rep(4,48),
          varianceratio=1) -> splitsplitsplitplotdesign

#A design's diagnostics can be accessed via the following attributes:

attr(design,"D") #D-Efficiency
attr(design,"A") #A-Efficiency
attr(design,"I") #The average prediction variance across the design space

#The correlation matrix can be accessed via the "correlation.matrix" attribute:

correlation.matrix = attr(design2, "correlation.matrix")

#A correlation color map can be produced by calling the plot_correlation command with the output
#of gen_design

plot_correlations(design2)

#A fraction of design space plot can be produced by calling the plot_fds command

plot_fds(design2)

#Evaluating the design for power can be done with eval_design, eval_design_mc (Monte Carlo)
#eval_design_survival_mc (Monte Carlo survival analysis), and
#eval_design_custom_mc (Custom Library Monte Carlo)
}

