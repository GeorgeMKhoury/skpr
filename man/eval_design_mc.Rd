% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_design_mc.R
\name{eval_design_mc}
\alias{eval_design_mc}
\title{Evaluates power for model matrix with a Monte Carlo simulation}
\usage{
eval_design_mc(RunMatrix, model, alpha, blocking = FALSE, nsim = 1000,
  glmfamily = "gaussian", varianceratios = NULL, rfunction = NULL,
  anticoef = NULL, delta = 2, contrasts = contr.sum,
  binomialprobs = NULL, parallel = FALSE)
}
\arguments{
\item{RunMatrix}{The run matrix of the design.}

\item{model}{The model used in the evaluation.}

\item{alpha}{The type-I error.}

\item{blocking}{Default FALSE. Set to TRUE if design has blocking structure.}

\item{nsim}{The number of simulations.}

\item{glmfamily}{String indicating the family of distribution for the glm function
(e.g. "gaussian", "binomial", "poisson")}

\item{varianceratios}{Default 1. The ratio of the whole plot variance to the run-to-run variance. For designs with more than one subplot
this ratio can be a vector specifying the variance ratio for each subplot. Otherwise, it will use a single value for all strata.}

\item{rfunction}{Random number generator function for the response variable. Should be a function of the form f(X, b, delta), where X is the
model matrix, b are the anticipated coefficients, and delta is a vector of blocking errors. typically something like rnorm(nrow(X), X * b + delta, 0)}

\item{anticoef}{The anticipated coefficients for calculating the power. If missing, coefficients
will be automatically generated based on the delta argument.}

\item{delta}{The signal-to-noise ratio. Default 2. This specifies the difference between the high
and low levels. If you do not specify anticoef, the anticipated coefficients will be half of delta.}

\item{contrasts}{The contrasts to use for categorical factors. Defaults to contr.sum.}

\item{binomialprobs}{Default NULL. If the glm family is binomial, user should specify a length-two vector consisting of the base probability and the maximum expected probability given all the level settings in the experiment. As an example, if the user wants to detect at an increase in successes from 0.5 to 0.8, the user would pass the vector c(0.5,0.8) to the argument}

\item{parallel}{Default FALSE. If TRUE, uses all cores available to speed up computation. WARNING: This can slow down computation if nonparallel time to complete the computation is less than a few seconds.}
}
\value{
A data frame consisting of the parameters and their powers. The parameter estimates from the simulations are stored in the 'estimates' attribute.
}
\description{
Evaluates design, given a run matrix, with a monte carlo simulation and returns
a data frame of parameter and effect powers.
}
\examples{
#We first generate a full factorial design using expand.grid:
factorialcoffee = expand.grid(cost=c(-1, 1),
                             type=as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                             size=as.factor(c("Short", "Grande", "Venti")))

#And then generate the 21-run D-optimal design using gen_design.

designcoffee = gen_design(factorialcoffee, model=~cost + type + size, trials=21, optimality="D")

#To evaluate this design using a normal approximation, we just use eval_design
#(here using the default settings for contrasts, delta, and the anticipated coefficients):

eval_design(RunMatrix=designcoffee, model=~cost + type + size, 0.05)

#To evaluate this design with a Monte Carlo method, we enter the same information
#used in eval_design, with the addition of the number of simulations "nsim" and the distribution
#family used in fitting for the glm "glmfamily". For gaussian, binomial, expontial, and poisson
#families, a default random generating function (rfunction) will be supplied. If another glm
#family is used or the default random generating function is not adequate, a custom generating
#function can be supplied by the user.

eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, alpha=0.05, nsim=100,
              glmfamily="gaussian")

#We see here we generate approximately the same parameter powers as we do
#using the normal approximation in eval_design. Like eval_design, we can also change
#delta to produce a different signal-to-noise ratio:

eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, alpha=0.05,
              nsim=100, glmfamily="gaussian", delta=1)

#Like eval_design, we can also evaluate the design with a different model than
#the one that generated the design.
eval_design_mc(RunMatrix=designcoffee, model=~cost + type, alpha=0.05,
              nsim=100, glmfamily="gaussian")


#And here it is evaluated with interactions included:
eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size + cost*type, 0.05,
              nsim=100, glmfamily="gaussian")

#We can also set "parallel=TRUE" to turn use all the cores available to speed up
#computation.
\dontrun{eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, 0.05,
              nsim=10000, glmfamily="gaussian", parallel=TRUE)}

#We can also evaluate split-plot designs. First, let us generate the split-plot design:

vhtc = expand.grid(Store=as.factor(c("A","B")))
htc = expand.grid(Temp = c(1,-1))

vhtcdesign = gen_design(candidateset=vhtc, model=~Store, trials=6, varianceratio=1)
htcdesign = gen_design(candidateset=htc, model=~Temp, trials=18,
                      splitplotdesign=vhtcdesign, splitplotsizes=rep(3,6),varianceratio=1)
splitplotdesign = gen_design(candidateset=factorialcoffee, model=~cost+type+size, trials=54,
                            splitplotdesign=htcdesign, splitplotsizes=rep(3,18),varianceratio=1)

#Each block has an additional noise term associated with it in addition to the normal error
#term in the model. This is specified by a vector specifying the additional variance for
#each split-plot level. This is equivalent to specifying a variance ratio of one between
#the whole plots and the sub-plots for gaussian models. See the accompanying paper
#_____ for further technical details.

#Evaluate the design. Note the decreased power for the blocking factors. If
eval_design_mc(RunMatrix=splitplotdesign, model=~Store+Temp+cost+type+size, alpha=0.05,
              nsim=100, glmfamily="gaussian", varianceratios = c(1,1))

#We can also use this method to evaluate designs that cannot be easily
#evaluated using normal approximations. Here, we evaluate a design with a binomial response and see
#if we can detect the difference between each factor changing whether an event
#70\% of the time or 90\% of the time.

factorialbinom = expand.grid(a=c(-1,1),b=c(-1,1))
designbinom = gen_design(factorialbinom,model=~a+b,trials=90,optimality="D",repeats=100)

eval_design_mc(designbinom,~a+b,alpha=0.2,nsim=100,anticoef=c(1.5,0.7,0.7),
              glmfamily="binomial")

#We can also use this method to determine power for poisson response variables.
#We design our test to detect if each factor changes the base rate of 0.2 by
#a factor of 2. We generate the design:

factorialpois = expand.grid(a=as.numeric(c(-1,0,1)),b=c(-1,0,1))
designpois = gen_design(factorialpois, ~a+b, trials=90, optimality="D", repeats=100)

eval_design_mc(designpois,~a+b,0.2,nsim=100,glmfamily="poisson", anticoef=c(log(0.2),log(2),log(2)))

#where the anticipated coefficients are chosen to set the base rate at 0.2
#(from the intercept) as well as how each factor changes the rate (a factor of 2, so log(2)).
#We see here we need about 90 test events to get accurately distinguish the three different
#rates in each factor to 90\% power.
}

