% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_design_mc.R
\name{eval_design_mc}
\alias{eval_design_mc}
\title{Evaluates power for model matrix with a Monte Carlo simulation}
\usage{
eval_design_mc(RunMatrix, model, alpha, nsim, glmfamily, blocknoise = NULL,
  rfunction = NULL, anticoef = NULL, delta = 2, conservative = FALSE,
  contrasts = contr.sum, parallel = FALSE)
}
\arguments{
\item{RunMatrix}{The run matrix of the design.}

\item{model}{The model used in the evaluation.}

\item{alpha}{The type-I error.}

\item{nsim}{The number of simulations.}

\item{glmfamily}{String indicating the family of distribution for the glm function
(e.g. "gaussian", "binomial", "poisson")}

\item{blocknoise}{Vector of noise levels for each block, one element per blocking level. See examples for details.}

\item{rfunction}{Random number generator function for the response variable. Should be a function of the form f(X, b, delta), where X is the
model matrix, b are the anticipated coefficients, and delta is a vector of blocking errors. typically something like rnorm(nrow(X), X * b + delta, 0)}

\item{anticoef}{The anticipated coefficients for calculating the power. If missing, coefficients
will be automatically generated based on the delta argument.}

\item{delta}{The signal-to-noise ratio. Default 2. This specifies the difference between the high
and low levels. If you do not specify anticoef, the anticipated coefficients will be half of delta.}

\item{conservative}{Default FALSE. Specifies whether default method for generating
anticipated coefficents should be conservative or not. TRUE will give the most conservative
estimate of power by setting all but one level in a categorical factor's anticipated coefficients
to zero.}

\item{contrasts}{The contrasts to use for categorical factors. Defaults to contr.sum.}

\item{parallel}{Default FALSE. If TRUE, uses all cores available to speed up computation.}

\item{blockfuntion}{Random number generator for the noise due to blocks. See examples for details.}
}
\value{
A data frame consisting of the parameters and their powers. The parameter estimates from the simulations are
stored in the 'estimates' attribute.
}
\description{
Evaluates design, given a run matrix, with a monte carlo simulation and returns
a data frame of parameter and effect powers.
}
\examples{
#We first generate a full factorial design using expand.grid:
factorialcoffee = expand.grid(cost=c(-1, 1),
                             type=as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                             size=as.factor(c("Short", "Grande", "Venti")))

#And then generate the 21-run D-optimal design using gen_design.

designcoffee = gen_design(factorialcoffee, model=~cost + type + size, trials=21, optimality="D")

#To evaluate this design using a normal approximation, we just use eval_design
#(here using the default settings for contrasts, delta, and the anticipated coefficients):

eval_design(RunMatrix=designcoffee, model=~cost + type + size, 0.05)

#To evaluate this design with a Monte Carlo method, we enter the same information
#used in eval_design, with the addition of the number of simulations "nsim" and the distribution
#family used in fitting for the glm "glmfamily". For gaussian, binomial, expontial, and poisson
#families, a default random generating function (rfunction) will be supplied. If another glm
#family is used or the default random generating function is not adequate, a custom generating
#function can be supplied by the user.

eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, alpha=0.05, nsim=100,
              glmfamily="gaussian")

#We see here we generate approximately the same parameter powers as we do
#using the normal approximation in eval_design. Like eval_design, we can also change
#delta to produce a different signal-to-noise ratio:

eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, alpha=0.05,
              nsim=100, glmfamily="gaussian", delta=1)

#Like eval_design, we can also evaluate the design with a different model than
#the one that generated the design.
eval_design_mc(RunMatrix=designcoffee, model=~cost + type, alpha=0.05,
              nsim=100, glmfamily="gaussian")

#Here we evaluate the design using conservative anticipated coefficients:
eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, 0.05,
              nsim=100, glmfamily="gaussian", conservative=TRUE)

#And here it is evaluated with interactions included:
eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size + cost*type, 0.05,
              nsim=100, glmfamily="gaussian")

#We can also set "parallel=TRUE" to turn use all the cores available to speed up
#computation.
\dontrun{eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, 0.05,
              nsim=10000, glmfamily="gaussian", parallel=TRUE)}

#We can also evaluate split-plot designs. First, let us generate the split-plot design:

vhtc = expand.grid(Store=as.factor(c("A","B")))
htc = expand.grid(Temp = c(1,-1))

vhtcdesign = gen_design(factorial=vhtc, model=~Store, trials=6, varianceRatio=1)
htcdesign = gen_design(factorial=htc, model=~Temp, trials=18, splitplotdesign=vhtcdesign, splitplotsizes=rep(3,6),varianceRatio=1)
splitplotdesign = gen_design(factorial=factorialcoffee, model=~cost+type+size, trials=54,
                            splitplotdesign=htcdesign, splitplotsizes=rep(3,18),varianceRatio=1)

#Each block has an additional noise term associated with it in addition to the normal error term in the model.
#This is specified by a vector specifying the additional variance for each split-plot level. This is equivalent to
#specifying a variance ratio of one between the whole plots and the sub-plots for gaussian models.
#See the accompanying paper _____ for further technical details.

#Evaluate the design. Note the decreased power for the blocking factors. If
eval_design_mc(RunMatrix=splitplotdesign, model=~Store+Temp+cost+type+size, alpha=0.05,
              nsim=100, glmfamily="gaussian", blocknoise = c(1,1))

#We can also use this method to evaluate designs that cannot be easily
#evaluated using normal approximations. Here, we evaluate a design with a binomial response and see
#if we can detect the difference between each factor changing whether an event
#70\% of the time or 90\% of the time.

factorialbinom = expand.grid(a=c(-1,1),b=c(-1,1))
designbinom = gen_design(factorialbinom,model=~a+b,trials=90,optimality="D",repeats=100)

eval_design_mc(designbinom,~a+b,alpha=0.2,nsim=100,anticoef=c(1.5,0.7,0.7),
              glmfamily="binomial")

#We can also use this method to determine power for poisson response variables.
#We design our test to detect if each factor changes the base rate of 0.2 by
#a factor of 2. We generate the design:

factorialpois = expand.grid(a=as.numeric(c(-1,0,1)),b=c(-1,0,1))
designpois = gen_design(factorialpois, ~a+b, trials=90, optimality="D", repeats=100)

eval_design_mc(designpois,~a+b,0.2,nsim=100,glmfamily="poisson", anticoef=c(log(0.2),log(2),log(2)))

#where the anticipated coefficients are chosen to set the base rate at 0.2
#(from the intercept) as well as how each factor changes the rate (a factor of 2, so log(2)).
#We see here we need about 90 test events to get accurately distinguish the three different
#rates in each factor to 90\% power.
}

