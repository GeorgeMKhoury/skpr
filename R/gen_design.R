#'@title Generates the optimal run matrix from candidate set, model, optimality criterion,
#'and desired number of runs.
#'
#'@description Creates design given a model and desired number of runs, returning the model matrix. Currently
#'Used with eval_design/eval_design_mc to produce power estimations for designs.
#'
#'@param candidateset A data frame of candidate test points. Usually this is a full factorial test matrix
#'generated for the factors in the model, but if you have disallowed combinations then make sure the candidate list
#'is consistent with them (e.g. by generating a full factorial and then removing disallowed combinations). If
#'the factor is continuous, it should be type numeric. If the factor is categorical, it should be
#'set as a factor.
#'@param model The model used to generate the test design.
#'@param trials The number of runs in the design.
#'@param splitplotdesign For a split-plot design, this is the design for all of the factors harder to change
#'than the current set of factors. These rows are replicated to the specified size for each block
#'(given in the argument splitplotsizes) and the optimal design is found for all of the factors given in the
#'candidateset argument, taking into consideration the fixed and replicated hard-to-change factors.
#'@param splitplotsizes Specifies the block size for each row of harder-to-change factors given in the
#'argument splitplotdesign. If the input is a vector, each entry of the vector determines the size of the sub-plot
#'for that whole plot setting. If the input is an integer, it generates a balanced design with equal-sized blocks.
#'@param optimality Default "D". The optimality criterion used in generating the design. For split-plot designs, skpr currently
#'only supports the D, I, A, and E criteria. Full list of supported criteria: "D", "I", "A", "Alias", "G", "T", or "E"
#'@param repeats The number of times to repeat the search for the best optimal condition. If missing, this defaults to 10.
#'@param varianceratio Default 1. The ratio between the interblock and intra-block variance for a given stratum in
#'a split plot design.
#'@param contrast Function used to generate the contrasts encoding for categorical variables. Default contr.simplex.
#'@param aliaspower Default 2. Degree of interactions to be used in calculating the alias matrix for alias optimal designs.
#'@param minDopt Default 0.95. Minimum value for the D-Optimality of a design when searching for alias optimal designs.
#'@param parallel Default FALSE. If TRUE, the optimal design search will use all the available cores. This can lead to a substantial speed-up, for complex designs.
#'@param timer Default FALSE. If TRUE, will print an estimate of the optimal design search time.
#'@param disallowedcombinations Default FALSE. Set TRUE if the candidate list has had any test points removed.
#'@return The optimal design. Attributes can be accessed with the attr function.
#'@export
#'@examples #Generate the basic factorial design used in generating the optimal design with expand.grid.
#'#Generating a basic 2 factor design:
#'basicdesign = expand.grid(x1=c(-1,1), x2=c(-1,1))
#'
#'#This candidate set is used as an input in the optimal design generation for a
#'#D-optimal design with 11 runs.
#'design = gen_design(candidateset=basicdesign, model=~x1+x2, trials=11)
#'
#'#We can also use the dot operator to automatically use all of the terms in the model:
#'design = gen_design(candidateset=basicdesign, model=~., trials=11)
#'
#'#Here we add categorical factors, specified by using "as.factor" in expand.grid:
#'categoricaldesign = expand.grid(a=c(-1,1), b=as.factor(c("A","B")),
#'                                c=as.factor(c("High","Med","Low")))
#'
#'#This candidate set is used as an input in the optimal design generation.
#'design2 = gen_design(candidateset=categoricaldesign, model=~a+b+c, trials=19)
#'
#'#We can also increase the number of times the algorithm repeats
#'#the search to increase the probability that the globally optimal design was found.
#'design2 = gen_design(candidateset=categoricaldesign, model=~a+b+c, trials=19, repeats=100)
#'
#'#You can also use a higher order model when generating the design:
#'design2 = gen_design(candidateset=categoricaldesign, model=~a+b+c+a*b*c, trials=12)
#'
#'#To evaluate a response surface design, include center points
#'#in the candidate set and do not include
#'#quadratic effects with categorical factors.
#'
#'designquad = expand.grid(a=c(1,0,-1), b=c(-1,0,1), c=c("A","B","C"))
#'
#'gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20)
#'
#'#The optimality criterion can also be changed:
#'gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20,optimality="I")
#'gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20,optimality="A")
#'
#'#A split-plot design can be generated by first generating an optimal blocking design using the
#'#hard-to-change factors and then using that as the input for the split-plots design.
#'#This generates an optimal subplot design that accounts for the existing split-plot settings.
#'#See the accompannying paper "___________" for details of the implementation.
#'
#'hardtochangefactor = expand.grid(Altitude=c(-1,1))
#'hardtochangedesign = gen_design(candidateset = hardtochangefactor, model=~Altitude, trials=11)
#'
#'#Now we can use the D-optimal blocked design as an input to our full design.
#'
#'easytochangefactors = expand.grid(Range=as.factor(c("Close","Medium","Far")), Power=c(1,-1))
#'
#'#Here, we specify the easy to change factors for the candidate set,
#'#and input the hard-to-change design along with a vector listing the number
#'#of repetitions within each block for the blocked design. There should be a size entry
#'#for every block and the number of runs specified in the trials argument needs to equal the
#'#sum of all of the block sizes or else the program will throw an error.
#'
#'#Since we have 11 runs in our hard-to-change design, we need a vector
#'#specifying the size of each 11 runs. Here we specify the blocks be three runs each
#'#(meaning the final design will be 33 runs):
#'
#'splitplotblocksize = rep(3,11)
#'
#'#Putting this all together:
#'designsplitplot = gen_design(easytochangefactors, ~Range+Power, trials=33,
#'                             splitplotdesign=hardtochangedesign,
#'                             splitplotsizes = splitplotblocksize)
#'
#'#The split-plot structure is encoded into the row names, with a period
#'#demarcating the blocking level. This process can be repeated for arbitrary
#'#levels of blocking (i.e. a split-plot design can be entered in as the hard-to-change
#'#to produce a split-split-plot design, which can be passed as another
#'#hard-to-change design to produce a split-split-split plot design, etc).
#'
#'extremelyhtcfactors = expand.grid(Location=as.character(c("East","West")))
#'veryhtcfactors = expand.grid(Climate = as.factor(c("Dry","Wet","Arid")))
#'htcfactors = expand.grid(Vineyard = as.factor(c("A","B","C","D")))
#'etcfactors = expand.grid(Age = c(1,-1))
#'
#'gen_design(extremelyhtcfactors, ~Location, trials=6,varianceratio=2) -> temp
#'gen_design(veryhtcfactors, ~Climate, trials=12, splitplotdesign = temp, splitplotsizes=rep(2,6),
#'           varianceratio=1) -> temp
#'gen_design(htcfactors, ~Vineyard, 48, splitplotdesign = temp, splitplotsizes = rep(4,12),
#'           varianceratio=1) -> temp
#'gen_design(etcfactors, ~Age, 192, splitplotdesign = temp, splitplotsizes = rep(4,48),
#'           varianceratio=1) -> splitsplitsplitplotdesign
#'
#'#A design's diagnostics can be accessed via the following attributes:
#'
#'attr(design,"D") #D-Efficiency
#'attr(design,"A") #A-Efficiency
#'attr(design,"I") #The average prediction variance across the design space
#'
#'#The correlation matrix can be accessed via the "correlation.matrix" attribute:
#'
#'correlation.matrix = attr(design2, "correlation.matrix")
#'
#'#A correlation color map can be produced by calling the plot_correlation command with the output
#'#of gen_design
#'
#'plot_correlations(design2)
#'
#'#A fraction of design space plot can be produced by calling the plot_fds command
#'
#'plot_fds(design2)
#'
#'#Evaluating the design for power can be done with eval_design, eval_design_mc (Monte Carlo)
#'#eval_design_survival_mc (Monte Carlo survival analysis), and
#'#eval_design_custom_mc (Custom Library Monte Carlo)
gen_design = function(candidateset, model, trials,
                      splitplotdesign = NULL, splitplotsizes = NULL, optimality="D",
                      repeats=10, varianceratio = 1, contrast=contr.simplex,
                      aliaspower = 2, minDopt = 0.95,
                      parallel=FALSE, timer=FALSE, disallowedcombinations=FALSE) {


  candidateset = unique(reduceRunMatrix(candidateset, model))
  candidatesetnormalized = candidateset

  #---- generate contrast list-----#

  contrastslist = list()
  for(x in names(candidateset[lapply(candidateset,class) %in% c("factor","character")])) {
    contrastslist[[x]] = contrast
  }

  if(length(contrastslist) == 0) {
    contrastslist = NULL
  }

  #----- Convert dot/quad formula to terms -----#
  if((as.character(model)[2] == ".")) {
    model = as.formula(paste("~", paste(attr(candidateset, "names"), collapse=" + "), sep=""))
  }

  if(as.character(model)[2] == "quad(.)") {
    if(any(lapply(candidateset,class) %in% c("factor","character"))) {
      stop("quad() function cannot be used in models with categorical factors. Manually specify your model")
    }
    modelvars = colnames(model.matrix(~.,data=candidateset,contrasts.arg = contrastslist))[-1]
    modellinear = paste(modelvars,collapse=" + ")
    modellinear = paste("~",modellinear,sep="")
    model = quad(as.formula(modellinear))
  }

  #------Normalize/Center numeric columns ------#
  for(column in 1:ncol(candidateset)) {
    if(class(candidatesetnormalized[,column]) == "numeric") {
      midvalue = mean(c(max(candidatesetnormalized[,column]),min(candidatesetnormalized[,column])))
      candidatesetnormalized[,column] = (candidatesetnormalized[,column]-midvalue)/(max(candidatesetnormalized[,column])-midvalue)
    }
  }
  if(!is.null(splitplotdesign)) {
    spdnormalized = splitplotdesign
    for(column in 1:ncol(spdnormalized)) {
      if(class(spdnormalized[,column]) == "numeric") {
        midvalue = mean(c(max(spdnormalized[,column]),min(spdnormalized[,column])))
        spdnormalized[,column] = (spdnormalized[,column]-midvalue)/(max(spdnormalized[,column])-midvalue)
      }
    }
  }

  if(is.null(contrast)) {
    contrast = function(n) contr.simplex(n,size=sqrt(n-1))
  }

  blocking=FALSE
  #generate blocked design with replicates
  if(!is.null(splitplotdesign)) {
    varianceRatios = c(attr(splitplotdesign,"varianceratios"),varianceratio)
    blocking = TRUE
    if(is.null(splitplotsizes)) {
      stop("If split plot design provided, user needs to input split plot sizes as well")
    }
    if(length(splitplotsizes) == 1) {
      splitplotsizes = rep(splitplotsizes,nrow(splitplotdesign))
    }
    if(trials != sum(splitplotsizes)) {
      stop("Blocked replicates does not equal the number of trials input")
    }
    if(nrow(splitplotdesign) != length(splitplotsizes)) {
      stop("Need to specify a size for each row in the given split plot design")
    }
    alreadyBlocking = FALSE
    initialrownames = rownames(splitplotdesign)
    blocklist = strsplit(initialrownames,".",fixed=TRUE)
    blockgroups = list(splitplotsizes)

    if(any(lapply(blocklist,length) > 1)) {
      alreadyBlocking = TRUE
      initialrownames = rep(rownames(splitplotdesign),splitplotsizes)
      blocklist = strsplit(initialrownames,".",fixed=TRUE)
      existingBlockStructure = do.call(rbind,blocklist)
      blockgroups = apply(existingBlockStructure,2,blockingstructure)
    }
    withinBlockRun = function(runs) {return(1:runs)}

    blockIndicators = rep(1:length(splitplotsizes),splitplotsizes)

    blockvars = colnames(splitplotdesign)
    blocks = list()
    for(i in 1:length(blockIndicators)) {
      blocks[[i]] = spdnormalized[blockIndicators[i],]
    }

    blockRuns = c()
    for(i in 1:length(splitplotsizes)) {
      blockRuns = c(blockRuns,withinBlockRun(splitplotsizes[i]))
    }

    if(length(blocks[[1]]) > 1) {
      splitPlotReplicateDesign = as.data.frame(do.call(rbind, blocks))
    } else {
      splitPlotReplicateDesign = as.data.frame(unlist(blocks))
    }

    colnames(splitPlotReplicateDesign) = blockvars
    if(alreadyBlocking) {
      rownames(splitPlotReplicateDesign) = paste(initialrownames, blockRuns,sep=".")
    } else {
      rownames(splitPlotReplicateDesign) = paste(blockIndicators, blockRuns,sep=".")
    }
    blockMatrixSize = sum(splitplotsizes)
    V = diag(blockMatrixSize)*varianceRatios[1]
    blockcounter = 2
    for(block in blockgroups) {
      V[1:block[1],1:block[1]] =  V[1:block[1],1:block[1]]+varianceRatios[blockcounter]
      placeholder = block[1]
      for(i in 2:length(block)) {
        V[(placeholder+1):(placeholder+block[i]),(placeholder+1):(placeholder+block[i])] = V[(placeholder+1):(placeholder+block[i]),(placeholder+1):(placeholder+block[i])] + varianceRatios[blockcounter]
        placeholder = placeholder + block[i]
      }
      blockcounter = blockcounter+1
    }
  }

  initialReplace = FALSE
  if(trials > nrow(candidateset)) {
    initialReplace = TRUE
  }

  genOutput = list(repeats)

  if(length(contrastslist) == 0) {
    candidatesetmm = model.matrix(model,candidatesetnormalized)
  } else {
    candidatesetmm = model.matrix(model,candidatesetnormalized,contrasts.arg=contrastslist)
  }
  amodel = aliasmodel(model,aliaspower)


  if(model == amodel && optimality == "Alias") {
    stop(paste0(c("Alias optimal selected, but full model specified with no aliasing at current aliaspower: ",
                  aliaspower,". Try setting aliaspower = ", aliaspower+1),collapse=""))
  }

  if(length(contrastslist) == 0) {
    aliasmm = model.matrix(amodel,candidatesetnormalized)
  } else {
    suppressWarnings({
      aliasmm = model.matrix(amodel,candidatesetnormalized,contrasts.arg=contrastslist)
    })
  }

  if(!blocking) {
    factors = colnames(candidatesetmm)
    mm = gen_momentsmatrix(factors,candidateset)
    if(!parallel) {
      if(!timer) {
        for(i in 1:repeats) {
          randomIndices = sample(nrow(candidatesetmm), trials, replace = initialReplace)
          genOutput[[i]] = genOptimalDesign(initialdesign = candidatesetmm[randomIndices,], candidatelist=candidatesetmm,
                                          condition=optimality, momentsmatrix = mm, initialRows = randomIndices,
                                          hasdisallowedcombinations = disallowedcombinations,
                                          aliasdesign = aliasmm[randomIndices,],
                                          aliascandidatelist = aliasmm, minDopt = minDopt)
        }
      } else {
        cat("Estimated time to completion ... ")
        ptm = proc.time()
        randomIndices = sample(nrow(candidatesetmm), trials, replace = initialReplace)
        genOutput[[1]] = genOptimalDesign(initialdesign = candidatesetmm[randomIndices,], candidatelist=candidatesetmm,
                                          condition=optimality, momentsmatrix = mm, initialRows = randomIndices,
                                          hasdisallowedcombinations = disallowedcombinations,
                                          aliasdesign = aliasmm[randomIndices,],
                                          aliascandidatelist = aliasmm, minDopt = minDopt)
        cat(paste(c("is: ", floor((proc.time()-ptm)[3]*(repeats-1)), " seconds."),collapse=""))
        for(i in 2:repeats) {
          randomIndices = sample(nrow(candidatesetmm), trials, replace = initialReplace)
          genOutput[[i]] = genOptimalDesign(initialdesign = candidatesetmm[randomIndices,], candidatelist=candidatesetmm,
                                            condition=optimality, momentsmatrix = mm, initialRows = randomIndices,
                                            hasdisallowedcombinations = disallowedcombinations,
                                            aliasdesign = aliasmm[randomIndices,],
                                            aliascandidatelist = aliasmm, minDopt = minDopt)
        }
      }
    } else {
      if(!timer) {
        cl <- parallel::makeCluster(parallel::detectCores())
        doParallel::registerDoParallel(cl, cores = parallel::detectCores())

        genOutput = foreach(i=1:repeats) %dopar% {
          randomIndices = sample(nrow(candidatesetmm), trials, replace = initialReplace)
          genOptimalDesign(initialdesign = candidatesetmm[randomIndices,], candidatelist=candidatesetmm,
                           condition=optimality, momentsmatrix = mm, initialRows = randomIndices,
                           hasdisallowedcombinations = disallowedcombinations,
                           aliasdesign = aliasmm[randomIndices,],
                           aliascandidatelist = aliasmm, minDopt = minDopt)
        }
        parallel::stopCluster(cl)
      } else {
        cl <- parallel::makeCluster(parallel::detectCores())
        doParallel::registerDoParallel(cl, cores = parallel::detectCores())

        cat("Estimated time to completion ... ")
        ptm = proc.time()
        randomIndices = sample(nrow(candidatesetmm), trials, replace = initialReplace)
        genOutputOne = genOptimalDesign(initialdesign = candidatesetmm[randomIndices,], candidatelist=candidatesetmm,
                                        condition=optimality, momentsmatrix = mm, initialRows = randomIndices,
                                        hasdisallowedcombinations = disallowedcombinations,
                                        aliasdesign = aliasmm[randomIndices,],
                                        aliascandidatelist = aliasmm, minDopt = minDopt)
        cat(paste(c("is: ", floor((proc.time()-ptm)[3]*(repeats-1)/parallel::detectCores(logical=FALSE)), " seconds."),collapse=""))

        genOutput = foreach(i=2:repeats) %dopar% {
          randomIndices = sample(nrow(candidatesetmm), trials, replace = initialReplace)
          genOptimalDesign(initialdesign = candidatesetmm[randomIndices,], candidatelist=candidatesetmm,
                           condition=optimality, momentsmatrix = mm, initialRows = randomIndices,
                           hasdisallowedcombinations = disallowedcombinations,
                           aliasdesign = aliasmm[randomIndices,],
                           aliascandidatelist = aliasmm, minDopt = minDopt)
        }
        parallel::stopCluster(cl)
        genOutput = as.list(c(genOutputOne,genOutput))
      }
    }
  } else {
    blockedContrastsList = list()
    for(x in names(splitPlotReplicateDesign[sapply(splitPlotReplicateDesign,class) == "factor"])) {
      blockedContrastsList[[x]] = contrast
    }
    if(length(blockedContrastsList) == 0) {
      blockedModelMatrix = model.matrix(~.,splitPlotReplicateDesign)
    } else {
      blockedModelMatrix = model.matrix(~.,splitPlotReplicateDesign,contrasts.arg=blockedContrastsList)
    }
    blockedFactors = c(colnames(blockedModelMatrix),colnames(candidatesetmm)[-1])
    blockedMM = gen_momentsmatrix(blockedFactors,splitPlotReplicateDesign)
    if (!parallel) {
      if(!timer) {
        for(i in 1:repeats) {
          randomIndices = sample(nrow(candidateset), trials, replace = initialReplace)
          genOutput[[i]] = genBlockedOptimalDesign(initialdesign = candidatesetmm[randomIndices,],
                                                   candidatelist=candidatesetmm, blockeddesign = blockedModelMatrix,
                                                   condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices,
                                                   blockedVar=V, aliasdesign = aliasmm[randomIndices,],
                                                   aliascandidatelist = aliasmm, minDopt = minDopt)
        }
      } else {
        cat("Estimated time to completion ... ")
        ptm = proc.time()
        randomIndices = sample(nrow(candidateset), trials, replace = initialReplace)
        genOutput[[1]] = genBlockedOptimalDesign(initialdesign = candidatesetmm[randomIndices,],
                                                 candidatelist=candidatesetmm, blockeddesign = blockedModelMatrix,
                                                 condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices,
                                                 blockedVar=V, aliasdesign = aliasmm[randomIndices,],
                                                 aliascandidatelist = aliasmm, minDopt = minDopt)
        cat(paste(c("is: ", floor((proc.time()-ptm)[3]*(repeats-1)), " seconds."),collapse=""))
        for(i in 2:repeats) {
          randomIndices = sample(nrow(candidateset), trials, replace = initialReplace)
          genOutput[[i]] = genBlockedOptimalDesign(initialdesign = candidatesetmm[randomIndices,],
                                                   candidatelist=candidatesetmm, blockeddesign = blockedModelMatrix,
                                                   condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices,
                                                   blockedVar=V, aliasdesign = aliasmm[randomIndices,],
                                                   aliascandidatelist = aliasmm, minDopt = minDopt)
        }
      }
    } else {
      if(!timer) {
        cl <- parallel::makeCluster(parallel::detectCores())
        doParallel::registerDoParallel(cl, cores = parallel::detectCores())

        genOutput = foreach(i=1:repeats) %dopar% {
          randomIndices = sample(nrow(candidateset), trials, replace = initialReplace)
          genBlockedOptimalDesign(initialdesign = candidatesetmm[randomIndices,],
                                  candidatelist=candidatesetmm, blockeddesign = blockedModelMatrix,
                                  condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices,
                                  blockedVar=V, aliasdesign = aliasmm[randomIndices,],
                                  aliascandidatelist = aliasmm, minDopt = minDopt)
        }
        parallel::stopCluster(cl)
      } else {
        cl <- parallel::makeCluster(parallel::detectCores())
        doParallel::registerDoParallel(cl, cores = parallel::detectCores())

        cat("Estimated time to completion ... ")
        ptm = proc.time()
        randomIndices = sample(nrow(candidateset), trials, replace = initialReplace)
        genOutputOne = genBlockedOptimalDesign(initialdesign = candidatesetmm[randomIndices,],
                                               candidatelist=candidatesetmm, blockeddesign = blockedModelMatrix,
                                               condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices,
                                               blockedVar=V, aliasdesign = aliasmm[randomIndices,],
                                               aliascandidatelist = aliasmm, minDopt = minDopt)
        cat(paste(c("is: ", floor((proc.time()-ptm)[3]*(repeats-1)/parallel::detectCores(logical=FALSE)), " seconds."),collapse=""))

        genOutput = foreach(i=2:repeats) %dopar% {
          randomIndices = sample(nrow(candidateset), trials, replace = initialReplace)
          genBlockedOptimalDesign(initialdesign = candidatesetmm[randomIndices,],
                                  candidatelist=candidatesetmm, blockeddesign = blockedModelMatrix,
                                  condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices,
                                  blockedVar=V, aliasdesign = aliasmm[randomIndices,],
                                  aliascandidatelist = aliasmm, minDopt = minDopt)
        }
        parallel::stopCluster(cl)
        genOutput = as.list(c(genOutputOne,genOutput))
      }
    }
  }

  designs = list()
  rowIndicies = list()
  criteria = list()

  for(i in 1:repeats) {
    designs[i] = genOutput[[i]]["modelmatrix"]
    rowIndicies[i] = genOutput[[i]]["indices"]
    criteria[i] = genOutput[[i]]["criterion"]
  }

  if(optimality == "D" || optimality == "T" || optimality == "E") {
    best = which.max(criteria)
    designmm = designs[[best]]
    rowindex = round(rowIndicies[[best]])
  }

  if(optimality == "A" || optimality == "I" || optimality == "Alias" || optimality == "G") {
    best = which.min(criteria)
    designmm = designs[[best]]
    rowindex = round(rowIndicies[[best]])
  }

  rowindex[rowindex == 0] = 1

  if(!blocking) {
    colnames(designmm) = factors
  } else {
    colnames(designmm) = blockedFactors
  }

  design = constructRunMatrix(rowIndices = rowindex, candidateList = candidateset)

  if(blocking) {
    design = cbind(splitPlotReplicateDesign,design)
  }

  attr(design,"D-Efficiency") =  capture.output(100*DOptimality(designmm)^(1/ncol(designmm))/nrow(designmm))
  attr(design,"A-Efficiency") = tryCatch({capture.output(AOptimality(designmm))
    }, error = function(e) {})
  if(!blocking) {
    tryCatch({
      attr(design,"G") = max(diag(candidatesetmm %*% solve(t(designmm) %*% designmm) %*% t(candidatesetmm)))
      attr(design,"T") = sum(diag(t(designmm) %*% designmm))
      attr(design,"E") = min(unlist(eigen(t(designmm) %*% designmm)["values"]))
      attr(design,"variance.matrix") = diag(nrow(designmm))
      attr(design,"I") = IOptimality(as.matrix(designmm),momentsMatrix = mm,blockedVar=diag(nrow(designmm)))
    }, error = function(e) {})
  } else {
    tryCatch({
      attr(design,"variance.matrix") = V
      attr(design,"I") = IOptimality(as.matrix(designmm),momentsMatrix = blockedMM, blockedVar = V)
    }, error = function(e) {})
  }
  attr(design,"model.matrix") = designmm
  attr(design,"generating.model") = model
  attr(design,"generating.criterion") = optimality
  attr(design,"generating.contrast") = contrast

  if(!blocking) {
    rownames(design) = 1:nrow(design)
    colnames(mm) = colnames(designmm)
    rownames(mm) = colnames(designmm)
    attr(design,"moments.matrix") = mm
    attr(design,"varianceratios") = varianceratio
  } else {
    rownames(design) = rownames(splitPlotReplicateDesign)
    colnames(blockedMM) = colnames(designmm)
    rownames(blockedMM) = colnames(designmm)
    attr(design,"moments.matrix") = blockedMM
    attr(design,"V") = V
    attr(design,"varianceratios") = varianceRatios
  }

  tryCatch({
    if(ncol(designmm) > 2) {
      correlation.matrix = capture.output(abs(cov2cor(covarianceMatrix(designmm))[-1,-1]))
      colnames(correlation.matrix) = colnames(designmm)[-1]
      rownames(correlation.matrix) = colnames(designmm)[-1]
      attr(design,"correlation.matrix") = round(correlation.matrix,8)
      if(amodel != model) {
        aliasmatrix = suppressWarnings({
          model.matrix(aliasmodel(model,aliaspower),design,contrasts.arg = contrastslist)[,-1]
        })
        A = solve(t(designmm) %*% designmm) %*% t(designmm) %*% aliasmatrix
        attr(design,"alias.matrix") = A
        attr(design,"trA") = sum(diag(t(A) %*% A))
      } else {
        attr(design,"alias.matrix") = "No alias matrix calculated: full model specified"
        attr(design,"trA") = "No alias trace calculated: full model specified"
      }
    }
  }, error = function(e) {})

  attr(design,"contrastslist") = contrastslist

  return(design)
}
globalVariables('i')
